import { useState, useMemo, useEffect, useSyncExternalStore, useReducer, Suspense } from 'react';
import { suspend } from 'suspend-react';
import { jsx } from 'react/jsx-runtime';
const _checkAuth = async (projectId, token) => {
  const headers = token ? {
    Authorization: "Bearer ".concat(token)
  } : void 0;
  const res = await fetch("https://".concat(projectId, ".api.sanity.io/v1/users/me"), {
    credentials: "include",
    headers
  });
  const json = await res.json();
  return Boolean(json == null ? void 0 : json.id);
};
const _lazyGroqStore = async () => {
  const pkg = await import('@sanity/groq-store');
  const {
    groqStore
  } = "default" in pkg ? pkg.default : pkg;
  return groqStore;
};
const _lazyEventSourcePolyfill = async () => {
  const pkg = await import('event-source-polyfill');
  const {
    EventSourcePolyfill
  } = "default" in pkg ? pkg.default : pkg;
  return EventSourcePolyfill;
};
function useParams(params) {
  const stringifiedParams = useMemo(() => JSON.stringify(params || {}), [params]);
  return useMemo(() => JSON.parse(stringifiedParams), [stringifiedParams]);
}
const _definePreview = _ref => {
  let {
    projectId,
    dataset,
    documentLimit = 3e3,
    subscriptionThrottleMs = 10,
    overlayDrafts = true,
    importEventSourcePolyfill,
    importGroqStore,
    preload,
    onPublicAccessOnly,
    checkAuth,
    includeTypes
  } = _ref;
  if (!projectId) {
    console.warn("No projectId set for createPreviewHook, returning dummy hook");
    const usePreview = function usePreview2() {
      console.warn("The hook returned by createPreviewHook is a dummy as there is no projectId set, returning null");
      return null;
    };
    return usePreview;
  }
  let store;
  return function usePreview(token, query, _params, _serverSnapshot) {
    if (typeof document === "undefined") {
      throw new Error("Calling usePreview outside a browser environment isn't supported. Ensure the component using the hook is only rendering on the client. For example by wrapping it in PreviewSuspense.");
    }
    if (!token && token !== null) {
      throw new Error("No `token` given to usePreview hook, if this is intentional then set it to `null`");
    }
    const [serverSnapshot] = useState(() => _serverSnapshot);
    const params = useParams(_params);
    if (!store) {
      if (onPublicAccessOnly) {
        const hasAuth = checkAuth(projectId, token);
        if (!hasAuth) {
          onPublicAccessOnly();
        }
      }
      const groqStore = importGroqStore();
      store = groqStore({
        projectId,
        dataset,
        documentLimit,
        subscriptionThrottleMs,
        includeTypes,
        token: token === null ? void 0 : token,
        // Lazy load the huge `event-source-polyfill`, but only if a token is specified
        EventSource: token === null ? void 0 : importEventSourcePolyfill(),
        listen: true,
        overlayDrafts
      });
    }
    const initial = serverSnapshot != null ? serverSnapshot : preload(store, query, params);
    const syncStore = useMemo(() => {
      let snapshot = initial;
      return {
        getServerSnapshot: serverSnapshot === void 0 ? void 0 : () => serverSnapshot,
        getSnapshot: () => snapshot,
        subscribe: onStoreChange => {
          const subscription = store.subscribe(query, typeof params === "undefined" ? {} : params, (err, result) => {
            if (err) {
              console.error("Error thrown in the usePreviewHook subscription", err);
              throw err;
            } else {
              snapshot = result;
              onStoreChange();
            }
          });
          return () => subscription.unsubscribe();
        }
      };
    }, [initial, params, query, serverSnapshot]);
    useEffect(() => {
      const callback = () => {
        store.close();
      };
      window.addEventListener("beforeunload", callback);
      return () => window.removeEventListener("beforeunload", callback);
    }, []);
    return useSyncExternalStore(syncStore.subscribe, syncStore.getSnapshot, syncStore.getServerSnapshot);
  };
};
const _preloadQuery = (store, query, params) =>
// eslint-disable-next-line no-warning-comments
// @todo: fix the casting to any here
store.query(query, params);
const definePreview = config => _definePreview({
  ...config,
  importEventSourcePolyfill: () => suspend(() => _lazyEventSourcePolyfill(), ["@sanity/preview-kit", "event-source-polyfill"]),
  importGroqStore: () => suspend(() => _lazyGroqStore(), ["@sanity/preview-kit", "@sanity/groq-store"]),
  preload: (store, query, params) => suspend(() => _preloadQuery(store, query, params), ["@sanity/preview-kit", "preload", query, JSON.stringify(params != null ? params : {})]),
  checkAuth: (projectId, token) => suspend(() => _checkAuth(projectId, token), ["@sanity/preview-kit", "checkAuth", projectId, token])
});
function PreviewSuspense(_ref2) {
  let {
    children,
    fallback
  } = _ref2;
  const [mounted, mount] = useReducer(() => true, false);
  useEffect(mount, [mount]);
  return /* @__PURE__ */jsx(Suspense, {
    fallback,
    children: mounted ? children : fallback
  });
}
export { PreviewSuspense, _checkAuth, _definePreview, _lazyEventSourcePolyfill, _lazyGroqStore, _preloadQuery, definePreview };
//# sourceMappingURL=index.js.map
